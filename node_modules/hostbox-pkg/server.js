const net = require('net');

const indexOf = (string='',...args) => String.prototype.indexOf.call(string,...args);
const split = (string='',...args) => String.prototype.split.call(string,...args);
const slice = (string='',...args) => String.prototype.slice.call(string,...args);
const trim = (string='') => String.prototype.trim.call(string);
const trimStart = (string='') => String.prototype.trimStart.call(string);
const trimEnd = (string='') => String.prototype.trimEnd.call(string);
const { log: stdout } = console;

const filter = (array, include) => Array.prototype.filter.call(array,include);
const map = (array, fn) => Array.prototype.map.call(array,fn);
// Stores Socket WeakRefs for the case of large requests
const socketMap = new WeakMap();

const createReadableHttpStream = (port=3000) =>
new ReadableStream({start(connection){
  net.createServer((socket) => 
    socket.on('close', () => connection.close()).on('data', (data) => connection.enqueue([data,socket]))
  ).listen(port);
}}).pipeThrough(new TransformStream({
  transform([data,socket],res){
    if (!socketMap.get(socket)) {
      
      const requestHeaderEndIdx = indexOf(data,'\r\n\r\n');
    
      const [requestLine, ...headerLines] = filter(
        split(slice(data,0,requestHeaderEndIdx, '\n'), (_) => _ /* No Empty lines */
      );
      
      /* GET / HTTP/1.1 */
      const [method, reqPath, httpVersion] = split(trimEnd(requestLine),' ', 3);
  
      // Early Exit gets implemented here.
      /* Label: { "value": 1.2.432 }.... */
      const headers = Object.fromEntries(map(filter(headerLines,Boolean), (noneEmptyLine) => {
        const seperatorIdx = indexOf(line, ':');
        return [ slice(noneEmptyLine,0,seperatorIdx), trim(slice(noneEmptyLine,seperatorIdx+1)) ];
      } ));
      
      stdout({ method, path, httpVersion, headers });  
      
      if (method === 'GET' {
        socket.write(`HTTP/1.1 200 OK\r\n\r\n<html><head></head><body>${split(reqPath,'/',2 /** Perf opt **/)[1]}</body></html>`);
        socket.end(stdout);
      }
      
      if (method === 'POST') {  
        //if (data.length - (requestHeaderEndIdx+4) === headers['Content-length']) {
          socketMap.set(socket,new WritableStream())
        //}
        new Response(slice(data,requestHeaderEndIdx+4)).body.pipeTo(socketMap.get(socket),{ preventClose: true });
      }

    } else {
      new Response(data).body.pipeTo(socketMap.get(socket),{ preventClose: true });
      // This is the next chunk of a chunked request (eg 20mb) after last chunk
      socket.write(`HTTP/1.1 200 OK\r\n\r\n${split(reqPath,'/')} ${body?.name}`);
      socket.end((err)=>{console.log(err)});
    }
  }
}));

createReadableHttpStream(3000).pipeTo(new WritableStream({write:console.log}));
