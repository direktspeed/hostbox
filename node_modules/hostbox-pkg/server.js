const net = require('net');

const split = (string='',pattern='') => String.prototype.split.call(string,pattern);
const trim = (string='') => String.prototype.trim.call(string);
const { log: stdout } = console;

const filter = (array, include) => Array.prototype.filter.call(array,include);
const map = (array, fn) => Array.prototype.map.call(array,fn);

const createReadableHttpStream = (port=3000) => new ReadableStream({ start(controller){
  net.createServer(socket => socket.on('data',controller.enqueue).on('close',controller.close)).listen(port);
}});

createReadableHttpStream(3000).pipeTo(new WriteableStream({write(data=''){
  const [requestAndHeadersText, ...bodyContent] = split(data,'\r\n\r\n');
      
  const [requestLine /* GET / HTTP/1.1 */, ...headerLines /* FILDNAME: value 1.2.432 */] = filter(
    split(requestAndHeadersText,'\n'), (_) => _ /* No Empty lines */
  );
  
  const [method, path, httpVersion] = split(trim(requestLine),' ');

  // Early Exit gets implemented here.
  
  const headers = Object.fromEntries(
    //map(
      map( filter(headerLines, (_) => _ /* No Empty lines */),  (line) => map(split(line,':', 1 /** Perf opt **/), trim) ) // ,
      // ([fildName, value]) => [fildName, value] // ([name, ...rest]) => [name, rest.join(' ')]
    //)
  );

  if (method === 'GET' {
            
    stdout({ method, path, httpVersion, headers });
    
    socket.write(`HTTP/1.1 200 OK\r\n\r\n<html><head></head><body>${path.split('/')[1]}</body></html>`);
    socket.end(stdout);
  }
    
  if (method === 'POST') {
  
    var body;
    try {
        body = JSON.parse(bodyContent);
    } catch(err){/* ignore */
      stdout({ err, method, path, httpVersion, headers, bodyContent });
      return;
    }

    stdout({ method, path, httpVersion, headers, body });
  
    socket.write(`HTTP/1.1 200 OK\r\n\r\n${split(path,'/')} ${body.name}`);
    socket.end((err)=>{console.log(err)});
    return 
  }
}}));
