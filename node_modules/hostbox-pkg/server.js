const net = require('net');

const indexOf = (string='',...args) => String.prototype.indexOf.call(string,...args);
const split = (string='',...args) => String.prototype.split.call(string,...args);
const slice = (string='',...args) => String.prototype.slice.call(string,...args);
const trim = (string='') => String.prototype.trim.call(string);
const trimStart = (string='') => String.prototype.trimStart.call(string);
const trimEnd = (string='') => String.prototype.trimEnd.call(string);
const { log: stdout } = console;

const filter = (array, include) => Array.prototype.filter.call(array,include);
const map = (array, fn) => Array.prototype.map.call(array,fn);

const createReadableHttpStream = (port=3000) => new ReadableStream({ start(controller){
  net.createServer(socket => { 
    
    controller.enqueue(socket)
    
  }).listen(port);
  net.createServer(socket => socket.on('data',(request)=>controller.enqueue([request,socket]).on('close',controller.close)).listen(port);
}});

const parseHttpRequest = (socket) => (data) => {
  const requestHeaderEndIdx = indexOf(data,'\r\n\r\n');
  
  const [requestLine /* GET / HTTP/1.1 */, ...headerLines /* Label: { "value": 1.2.432 }.... */] = filter(
    split(slice(data,0,requestHeaderEndIdx, '\n'), (_) => _ /* No Empty lines */
  );
  
  const [method, reqPath, httpVersion] = split(trimEnd(requestLine),' ', 3);

  // Early Exit gets implemented here.
  
  const headers = Object.fromEntries(map(filter(headerLines,Boolean), (noneEmptyLine) => {
      const seperatorIdx = indexOf(line, ':');
      return [ slice(noneEmptyLine,0,seperatorIdx), trim(slice(noneEmptyLine,seperatorIdx+1)) ];
  } ));

  if (method === 'GET' {
            
    stdout({ method, reqPath, httpVersion, headers });
    
    socket.write(`HTTP/1.1 200 OK\r\n\r\n<html><head></head><body>${split(reqPath,'/',2 /** Perf opt **/)[1]}</body></html>`);
    socket.end(stdout);
  }
    
  if (method === 'POST') {  
    // data.length - (requestHeaderEndIdx+4) === headers['Content-length']
    const bodyContent = new Response(slice(data,requestHeaderEndIdx+4)).json().catch(console.error);
    // for large post support we would add socket.ondata =   
    stdout({ method, path, httpVersion, headers, body: await bodyContent });
  
    socket.write(`HTTP/1.1 200 OK\r\n\r\n${split(reqPath,'/')} ${body?.name}`);
    socket.end((err)=>{console.log(err)});
    return 
  }
}


createReadableHttpStream(3000).pipeTo(new WriteableStream({async write(socket){
  //const [requestAndHeadersText, bodyContent] = [slice(data,0,indexOf(data,'\r\n\r\n'),slice(data,indexOf(data,'\r\n\r\n')+1];
  
  socket.ondata = parseHttpRequest(socket);
  socket.on('data',(data)=>socket.ondata(data))
}}));
